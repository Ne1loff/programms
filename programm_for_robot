#pragma config(Sensor, port1,  color_left,     sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port2,  color_right,    sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port6,  cube_color,     sensorVexIQ_Color12Color)
#pragma config(Sensor, port8,  gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port9,  LED,            sensorVexIQ_LED)
#pragma config(Motor,  motor4,          kleshnya,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          kleshnya_up_down, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor7,          motor_left,    tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motor10,         ruka_gigant,   tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         bagazhnik,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor12,         motor_right,   tmotorVexIQ, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool bagazh = false;
bool home = false;
int turn1 = 0, way = 0;


void begin();
void the_end();
void turn(int dg, int k, int n);
void choose_your_way();
void move_online();
void turn_right();
void turn_left();
void go_to_home();
void move (int Vl, int Vr, int Ti);
void turn_around();
void trow_cube();
void take_cube();
void color();
void return_to_stuck_position();
void unload();
void sho_za_color();
void go_to_red_1();
void go_to_red_2();
void go_to_green_1();
void go_to_green_2();
void go_to_blue();
void go_to_yellow();

int dst (int d) {
 float a = 23.5;
 return floor((d/a)*360);
}

void turn (int dg, int k, int n)
{
	resetGyro(gyro);
	wait10Msec(10);
	while(dg - getGyroDegrees(gyro) != 0)
	{
		setMotorSpeed(motor_left, -k * (dg - getGyroDegrees(gyro)));
		setMotorSpeed(motor_right, k * (dg - getGyroDegrees(gyro)));
	}
	int i = 0;
	while (i < n)
	{
		setMotorSpeed(motor_left, -k * (dg - getGyroDegrees(gyro)));
		setMotorSpeed(motor_right, k * (dg - getGyroDegrees(gyro)));
		i++;
	}
	/*wait10Msec(50);
	 if (dg < 0) {
	    setMotorSpeed(motor_left,   20);
	    setMotorSpeed(motor_right, -20);
   } else {
	   setMotorSpeed(motor_left,  -20);
	   setMotorSpeed(motor_right,  20);
   }
   while (!vexRT[BtnEUp]) {}
	 setMotorSpeed(motor_left,  0);
	 setMotorSpeed(motor_right, 0);*/
}

void move_on_time(int Vl, int Vr, int Ti)
{
	motor[motor_left] = Vl;
	motor[motor_right] = Vr;
	wait1Msec(Ti);
}

void choose_your_way()
{
	/*switch ()
	{

	}*/
}

void begin()
{
	motor[ruka_gigant] = -100;
	wait1Msec(4200);
	motor[ruka_gigant] = 0;
	motor[kleshnya_up_down] = - 30;
	wait1Msec(720);
	motor[kleshnya_up_down] = 0;
	motor[ruka_gigant] = -45;
	wait1Msec(2000);
	motor[ruka_gigant] = 0;
	motor[kleshnya] =  40;
	wait1Msec(950);
	motor[kleshnya] = 0;
	motor[bagazhnik] = 70;
	wait1Msec(650);
	motor[bagazhnik] = 0;

}

void the_end()
{

	motor[bagazhnik] = -70;
	wait1Msec(650);
	motor[bagazhnik] = 0;
	motor[ruka_gigant] = 100;
	wait1Msec(4200);
	motor[ruka_gigant] = 0;
	motor[kleshnya_up_down] = 30;
	wait1Msec(720);
	motor[kleshnya_up_down] = 0;
	motor[ruka_gigant] = 45;
	wait1Msec(2200);
	motor[ruka_gigant] = 0;
	motor[kleshnya] =  -40;
	wait1Msec(1000);
	motor[kleshnya] = 0;
}
void go_to_home()
{
	move (20, 20, 10);
	turn (- 92, 2, 0);
	for (int i = 0; i < 6; i++)
	{
		move (50, 50, 20);
		move_online();
	}
	move (50, 50, 30);
	move (0, 0, 0);
}

void move_online()
{

	 int i = 0;
	 int n = 100;
	 while(i < n)
	 {
	   displayTextLine(3, "%d", i);
		if (SensorValue(color_left) > 122)
		{
			if(SensorValue(color_right) > 122)
				{
					move_on_time (40, 40, 0);
				}
			else
			 {
				  move_on_time(40, 10, 0);
			 }
		}
		else if (SensorValue(color_right) < 122)
			    move_on_time (40, 10, 0);
			   else
			   {
			    move_on_time (40, 40, 0);
			   }
			   i++;
			 }
	}

void sho_za_color()
{
	if (getColorName(cube_color) == colorRed)
	 {
	   if (way == 1)
	     way = 11;
	   else
	     way = 1;
		 if (way != 0)
		   color();
	 }
	if (getColorName(cube_color) == colorBlueGreen)
	 {
		 way = 2;
		 if (way != 0)
		 color();
		}
	if (getColorName(cube_color) == colorGreen)
		{
		 if (way == 3)
		   way = 33;
		 else
		   way = 3;
		 if (way != 0)
		 	 color();
		}
	if (getColorName(cube_color) == colorYellow)
		{
		 way = 4;
		 if (way != 0)
		   color();
		}
		displayTextLine(1,"%d", way);
}

void go_to_red_1()
{
	setTouchLEDColor(LED, colorRed);
	move (40, 40, 30);
	move_online();
	move (40, 40, 24);
	move_online();
	move_online();
	take_cube();
	turn_around();
	unload();
	go_to_blue();
}
void go_to_red_2()
{

}

void go_to_blue()
{
	setTouchLEDColor(LED, colorBlueGreen);
	move (20, 20, 10);
	turn_left();
	for(int i = 0; i <5; i++)
	{
	    	move (50, 50, 20);
	    	move_online();
	}
	move (50, 50, 10);
  turn_right();
	move (20, 20, 30);
	take_cube();
	turn_around();
	unload();
	go_to_yellow();
}

void go_to_yellow()
{
	setTouchLEDColor(LED, colorYellow);
	move (20, 20, 10);
	turn_left();
	for (int i = 0; i < 2; i++)
	{
		move (40, 40, 20);
		move_online();
	}
	move (40, 40, 17);
	turn_right();
	move (20, 20, 27);
	turn_around();
	home = true;
	unload();
	//if (home == false)
	//	sho_za_color();
	//else

}

void unload()
{
	motor[bagazhnik] = - 50;
	wait1Msec(2000);
	motor[bagazhnik] = 0;
	move_online();
	move(30, 30, 20);
	move(0, 0, 0);
	motor[bagazhnik] = 60;
	wait1Msec(1800);
	motor[bagazhnik] = 0;
	if (home == false)
		trow_cube();
}

void return_to_stuck_position()
{
	motor[ruka_gigant] = -101;
	wait1Msec(2100);
	motor[ruka_gigant] = 0;
	motor[ruka_gigant] = -40;
	wait1Msec(1100);
	motor[ruka_gigant] = 0;
}

void turn_left()
{
	turn (90, 2, 50);
}

void turn_right()
{
	turn (-90, 2, 50);
}

void turn_around()
{
	turn (180, 2, 100);
}

void trow_cube()
{
	motor[ruka_gigant] = 101;
	wait1Msec(1620);
	motor[ruka_gigant] = 0;
	motor[kleshnya_up_down] = - 50;
	wait1Msec(1920);
	motor[kleshnya_up_down] = 0;
	motor[kleshnya] = 45;
	wait1Msec(1600);
	motor[kleshnya] = 0;
	return_to_stuck_position();
	bagazh = true;
}

void take_cube()
{
	move (0, 0, 0);
	motor[ruka_gigant] = 55;
	wait1Msec(1870);
	motor[ruka_gigant] = 0;
	motor[kleshnya_up_down] = 50;
	wait1Msec(1920);
	motor[kleshnya_up_down] = 0;
	motor[kleshnya] = - 45;
	wait1Msec(1600);
	motor[kleshnya] = 0;
	motor[ruka_gigant] = 55;
	wait1Msec(500);
	motor[ruka_gigant] = 0;
	turn1 = 1;
}

void color()
{
	wait1Msec(200);
	move(0, 0, 0);
	take_cube();
	wait1Msec(200);
	if (bagazh == false)
	  {
	    trow_cube();
	    turn_around();
	    go_to_red_1();
	  }
	else
		{
	 	  turn_around();
			unload();
			//home = true;
			go_to_blue();
		}
	/*if (way == 1)
	{
		way = 0;
		go_to_red_1();
	}
	if (way == 2)
	{
		way = 0;
		go_to_blue();
	}
	if (way == 3)
	{
		way = 0;
		go_to_yellow();
	}*/
}

void move (int Vl, int Vr, int Ti)
{
	resetMotorEncoder(motor_left);
	resetMotorEncoder(motor_right);
	int dsta = dst(Ti);
	setMotorTarget(motor_left, dsta, Vl);
	setMotorTarget(motor_right, dsta, Vr);
	waitUntilMotorMoveComplete(motor_left);
  /* wait10Msec(50);
   setMotorSpeed(motor_left,  Vl);
	 setMotorSpeed(motor_right, Vr);
   while (!vexRT[BtnEUp]) {}
	 setMotorSpeed(motor_left,  0);
	 setMotorSpeed(motor_right, 0);*/
}

void start_work()
{
 move (40, 40, 85);
 turn_right();
 move_online();
 move (20, 20, 28);
}



task main()
{
	wait1Msec(300);
	begin();
	start_work();

	while(home == false)
	{
		color();
	}

	go_to_home();
	wait1Msec(300);
	the_end();
	//turn_around();
}
