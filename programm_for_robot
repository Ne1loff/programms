#pragma config(Sensor, port1,  color_left,     sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port2,  color_right,    sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port6,  cube_color,     sensorVexIQ_Color12Color)
#pragma config(Sensor, port8,  gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port9,  LED,            sensorVexIQ_LED)
#pragma config(Motor,  motor4,          kleshnya,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          kleshnya_up_down, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor7,          motor_left,    tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motor10,         ruka_gigant,   tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         zhepa,         tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor12,         motor_right,   tmotorVexIQ, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool bagazh = false;
bool home = false;
int turn = 0, way = 0;


void begin();
void the_end();
void choose_your_way();
void move_online();
void turn_right();
void turn_left();
void go_to_home();
void move (int Vl, int Vr, int Ti);
void turn_around();
void trow_cube();
void take_cube();
void color();
void return_to_stuck_position();
void unload();
void sho_za_color();
void go_to_red_1();
void go_to_red_2();
void go_to_green_1();
void go_to_green_2();
void go_to_blue();
void go_to_yellow();

int dst (int d) {
 float a = 23.5;
 return floor((d/a)*360);
}

void move_on_time(int Vl, int Vr, int Ti)
{
	motor[motor_left] = Vl;
	motor[motor_right] = Vr;
	wait1Msec(Ti);
}

void choose_your_way()
{
	/*switch ()
	{
		
	}*/
}

void begin()
{
	motor[ruka_gigant] = -100;
	wait1Msec(4000);
	motor[ruka_gigant] = 0;
	motor[ruka_gigant] = -45;
	wait1Msec(2100);
	motor[ruka_gigant] = 0;
	motor[kleshnya] =  40;
	wait1Msec(1000);
	motor[kleshnya] = 0;
	motor[zhepa] = 60;
	wait1Msec(500);
	motor[zhepa] = 0;
	
}

void the_end()
{
	motor[ruka_gigant] = 100;
	wait1Msec(4000);
	motor[ruka_gigant] = 0;
	motor[ruka_gigant] = 45;
	wait1Msec(2100);
	motor[ruka_gigant] = 0;
	motor[kleshnya] =  -40;
	wait1Msec(1000);
	motor[kleshnya] = 0;
	motor[zhepa] = -60;
	wait1Msec(500);
	motor[zhepa] = 0;
	
}
void go_to_home()
{
	move (20, 20, 10);
	turn_right();
	for (int i = 0; i < 5; i++)
	{
		move (50, 50, 20);
		move_online();
	}
	move(0, 0, 0);
}

void move_online()
{
		if (SensorValue(color_left) > 122)
		{
			if(SensorValue(color_right) > 122)
				{
					move_on_time (40, 40, 0);
				}
			else
			 {
				  move_on_time(40, 10, 0);
			 }
		}
		else if (SensorValue(color_right) < 122)
			    move_on_time (40, 10, 0);
			   else 
			   {
			    turn_right();
			   }
	}

void sho_za_color()
{
	if (getColorName(cube_color) == colorRed)
	 {
	   if (way == 1)
	     way = 11;
	   else
	     way = 1;
		 if (way != 0)
		   color();
	 }
	if (getColorName(cube_color) == colorBlueGreen)
	 {
		 way = 2;
		 if (way != 0)
		 color();
		}
	if (getColorName(cube_color) == colorGreen)
		{
		 if (way == 3)
		   way = 33;
		 else
		   way = 3;
		 if (way != 0)
		 	 color();
		}
	if (getColorName(cube_color) == colorYellow)
		{
		 way = 4;
		 if (way != 0)
		   color();
		}
		displayTextLine(1,"%d", way);
}

void go_to_red_1()
{
	setTouchLEDColor(LED, colorRed);
	move (40, 40, 20);
	move_online();
	move (40, 40, 20);
	move_online();
	move (40, 40, 20);
	move_online();
	take_cube();
	turn_around();
	unload();
	go_to_blue();
}
void go_to_red_2()
{

}

void go_to_blue()
{
	setTouchLEDColor(LED, colorBlueGreen);
	move (20, 20, 20);
	turn_left();
	for(int i = 0; i <5; i++)
	{
		move (50, 50, 20);
	  move_online();
	}
	turn_right();
	move (20, 20, 30);
	take_cube();
	turn_around();
	unload();
	go_to_yellow();
}

void go_to_yellow()
{
	setTouchLEDColor(LED, colorYellow);
	move (20, 20, 10);
	turn_left();
	for (int i = 0; i < 3; i++)
	{
		move (40, 40, 20);
		move_online();
	}
	turn_right();
	move (20, 20, 20);
	turn_around();
	home = true;
	unload();
	if (home == false)
		sho_za_color();
	else
		return;

}

void unload()
{
	motor[zhepa] = - 100;
	wait1Msec(800);
	motor[zhepa] = 0;
	move(30, 30, 20);
	move(0, 0, 0);
	motor[zhepa] = 100;
	wait1Msec(800);
	motor[zhepa] = 0;
	if (home == false)
		trow_cube();
}

void return_to_stuck_position()
{
	motor[ruka_gigant] = -100;
	wait1Msec(2000);
	motor[ruka_gigant] = 0;
	motor[ruka_gigant] = -45;
	wait1Msec(1100);
	motor[ruka_gigant] = 0;
}

void turn_left()
{
	resetGyro(gyro);
	setMotorSpeed(motor_left, - A10);
	setMotorSpeed(motor_right, 30);
	while (getGyroDegrees(gyro) < 90)
	{
		displayTextLine(0, "%d", getGyroDegrees(gyro));
	}
}

void turn_right()
{
	resetGyro(gyro);
	setMotorSpeed(motor_left,30);
	setMotorSpeed(motor_right, -10);
	while (getGyroDegrees(gyro) > - 90)
	{
		displayTextLine(0, "%d", getGyroDegrees(gyro));
	}
	move (0, 0, 0);
}

void turn_around()
{
	resetGyro(gyro);
	setMotorSpeed(motor_left,30);
	setMotorSpeed(motor_right, -10);
	while (getGyroDegrees(gyro) > - 180)
	{
		displayTextLine(1, "%d", getGyroDegrees(gyro));
	}
	move(0, 0, 0);
}

void trow_cube()
{
	motor[ruka_gigant] = 101;
	wait1Msec(2000);
	motor[ruka_gigant] = 0;
	motor[kleshnya_up_down] = - 45;
	wait1Msec(2000);
	motor[kleshnya_up_down] = 0;
	motor[kleshnya] = 50;
	wait1Msec(2000);
	motor[kleshnya] = 0;
	return_to_stuck_position();
	bagazh = true;
}

void take_cube()
{
	move (0, 0, 0);
	motor[ruka_gigant] = 55;
	wait1Msec(1700);
	motor[ruka_gigant] = 0;
	motor[kleshnya_up_down] = 45;
	wait1Msec(1900);
	motor[kleshnya_up_down] = 0;
	motor[kleshnya] = - 45;
	wait1Msec(1900);
	motor[kleshnya] = 0;
	turn = 1;
}

void color()
{
	wait1Msec(200);
	move(0, 0, 0);
	take_cube();
	wait1Msec(200);
	if (bagazh == false)
	  {
	    trow_cube();
	    turn_around();
	    go_to_red_1();
	  }
	else
		{
	 	  turn_around();
			unload();
			go_to_blue();
		}
	/*if (way == 1)
	{
		way = 0;
		go_to_red_1();
	}
	if (way == 2)
	{
		way = 0;
		go_to_blue();
	}
	if (way == 3)
	{
		way = 0;
		go_to_yellow();
	}*/
}

void move (int Vl, int Vr, int Ti)
{
	resetMotorEncoder(motor_left);
	resetMotorEncoder(motor_right);
	int dsta = dst(Ti);
	setMotorTarget(motor_left, dsta, Vl);
	setMotorTarget(motor_right, dsta, Vr);
	waitUntilMotorMoveComplete(motor_left);
}

void start_work()
{
 move (40, 40, 20);
}



task main()
{
	wait1Msec(300);
	begin();
	start_work();
	
	while(home == false)
	{
		move_online();
		sho_za_color();
	}
	go_to_home();
	the_end();
}
